<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Namárië</title>
    <description></description>
    <link>fdgdfgfdg/</link>
    <atom:link href="fdgdfgfdg/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 29 Jan 2016 06:50:02 +0000</pubDate>
    <lastBuildDate>Fri, 29 Jan 2016 06:50:02 +0000</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>jsoup学习笔记(三):模拟登录</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;如上文所述，未登录状态爬取信息时会有很多限制，那么就来看看如何模拟登录知乎&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;cookie&quot;&gt;采用最暴力的方法：硬塞cookie&lt;/h3&gt;

&lt;p&gt;首先，在浏览器上登录帐号，然后提取到cookie&lt;/p&gt;

&lt;p&gt;关于如何获取，各个浏览器不一样，可以针对自己的百度下&lt;/p&gt;

&lt;p&gt;拿到cookie值后，在程序里硬编码写入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Connection con = Jsoup.connect(&quot;https://www.zhihu.com&quot;);//获取连接
con.header(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:29.0) Gecko/20100101 Firefox/29.0&quot;);//配置模拟浏览器
Map&amp;lt;String, String&amp;gt; cookie = new HashMap&amp;lt;&amp;gt;();
cookie.put(&quot;_xsrf&quot;, &quot;af8cfcba675ae98ae5a6e238b2844238&quot;);
cookie.put(&quot;_za&quot;, &quot;7699d7fa-905b-44bf-9a08-583ca27692b3&quot;);
cookie.put(&quot;__utma&quot;, &quot;51854390.1095779136.1452616328.1452616328.1452616328.1&quot;);
cookie.put(&quot;__utmb&quot;, &quot;51854390.14.10.1452616328&quot;);
cookie.put(&quot;__utmc&quot;, &quot;51854390&quot;);
//...许多cookie，省略
con.cookies(cookie);
Connection.Response rs = con.execute();
Document doc = Jsoup.parse(rs.body());
System.out.println(doc);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如之前所料，是已登录的状态&lt;/p&gt;

&lt;p&gt;此方法只是权宜之计，比如临时写一个只会用几次的爬虫程序&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;模拟登录知乎&lt;/h3&gt;

&lt;p&gt;下面一步步分析&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;1.请求地址&lt;/h4&gt;
&lt;p&gt;使用chrome开发者工具中的network功能抓取：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Request URL:https://www.zhihu.com/login/email&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-2&quot;&gt;2.需要哪些字段&lt;/h4&gt;

&lt;p&gt;打开知乎首页，观察登录表单&lt;/p&gt;

&lt;p&gt;帐号密码输入框、验证码输入框&lt;/p&gt;

&lt;p&gt;随便填几个值，点登录，使用chrome开发者工具中的network功能抓取请求头form data：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_xsrf:88d1ff7fd5a1f66f306b8f720a7322b8
password:123456
captcha:1234
remember_me:true
email:12345678
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现五个字段&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;_xsrf，暂时不知道作用，猜测是一种验证机制&lt;/li&gt;
  &lt;li&gt;email、password，见名知意，帐号密码&lt;/li&gt;
  &lt;li&gt;remember，是否记住帐号&lt;/li&gt;
  &lt;li&gt;captcha，验证码值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;只有_xsrf不知其意，查看网页源代码，发现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&quot;hidden&quot; name=&quot;_xsrf&quot; value=&quot;88d1ff7fd5a1f66f306b8f720a7322b8&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ok，管你是什么意思，我先发一次请求拿到你，第二次的时候直接塞进去不就得了
如码所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void getXsrf() {
		con = Jsoup.connect(&quot;http://www.zhihu.com&quot;);
		con.header(&quot;User-Agent&quot;, userAgent);
		try {
			rs = con.execute();
		} catch (Exception e) {
			log.info(&quot;获得Xsrf失败&quot;);
			return;
		}
		Document doc=Jsoup.parse(rs.body());
		_xsrf=doc.select(&quot;.view.view-signin [name=\&quot;_xsrf\&quot;]&quot;).attr(&quot;value&quot;);
		log.info(&quot;已获得xsrf&quot;);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-3&quot;&gt;3.如何获取验证码&lt;/h4&gt;

&lt;p&gt;查看网页源代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img class=&quot;js-refresh-captcha captcha&quot; width=&quot;120&quot; height=&quot;30&quot; data-tip=&quot;s$t$看不清楚？换一张&quot; alt=&quot;验证码&quot; src=&quot;/captcha.gif?r=1453549553883&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到验证码地址：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;www.zhihu.com/captcha.gif?r=一些数字&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;很容易可以看出，r的值为Unix时间戳&lt;/p&gt;

&lt;p&gt;下一步，代码实现下载验证码到本地，并保存该验证码的cookie，为后面登录做准备&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private Map&amp;lt;String,String&amp;gt; captchaCookies =new HashMap&amp;lt;&amp;gt;();
....
public void getCaptcha() {
		captchaCookies.clear();
		log.info(System.currentTimeMillis());
		con = Jsoup.connect(&quot;https://www.zhihu.com/captcha.gif?r=&quot; + System.currentTimeMillis()).ignoreContentType(true);//获取连接
		con.header(&quot;User-Agent&quot;, userAgent);
		try {
			rs = con.execute();
		} catch (Exception e) {
			log.info(&quot;获得验证码cookie失败&quot;);
			return;
		}
		File file = new File(&quot;cabeza.gif&quot;);
		try {
			FileOutputStream out = (new FileOutputStream(file));
			out.write(rs.bodyAsBytes());
		} catch (IOException e) {
			e.printStackTrace();
		}
		captchaCookies.putAll(rs.cookies());
		log.info(&quot;验证码已保存&quot; + &quot;,路径为:&quot; + file.getAbsolutePath());
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证码和对应cookie拿到后，下面就是登录了&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;4.根据上述五个字段，实现登录&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;public void getLoginCookies() {
    loginCookies.clear();
    Scanner sc=new Scanner(System.in);
    getXsrf();	//获取_xsrf
    getCaptchaCookies();	//获取验证码和验证码cookie
    log.info(&quot;请输入帐号&quot;);
    String userName=sc.nextLine();
    log.info(&quot;请输入密码&quot;);
    String passWord=sc.nextLine();
    log.info(&quot;请打开工程路径查看验证码并输入&quot;);
    String captcha=sc.nextLine();
    con = Jsoup.connect(&quot;https://www.zhihu.com/login/email&quot;);
    con.header(&quot;User-Agent&quot;, userAgent);
    try {
        rs = con.ignoreContentType(true).method(Connection.Method.POST)
                .data(&quot;_xsrf&quot;, _xsrf)
                .data(&quot;email&quot;, userName)
                .data(&quot;password&quot;, passWord)
                .data(&quot;captcha&quot;, captcha).cookies(captchaCookies).execute();
    } catch (Exception e) {
        log.info(&quot;获得loginCookies失败&quot;);
        return;
    }
    loginCookies.putAll(rs.cookies());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-5&quot;&gt;5.一些后续工作&lt;/h4&gt;
&lt;p&gt;拿到登录cookie后，为了方便下次登录，可以将cookie保存到文件，下次先从文件读取cookie登录，若失败，再使用上文方法登录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void saveCookies(String fileName, Map&amp;lt;String, String&amp;gt; cookies) {
    FileOutputStream fos = null;
    try {
        fos = new FileOutputStream(fileName);
    } catch (IOException e) {
        e.printStackTrace();
    }
    BufferedOutputStream bos
            = new BufferedOutputStream(fos);
    PrintWriter pw = new PrintWriter(bos);
    for (Map.Entry&amp;lt;String, String&amp;gt; entry : cookies.entrySet()) {
        pw.println(entry.getKey() + &quot;=&quot; + entry.getValue().replace(&quot;\&quot;&quot;,&quot;&quot;));
    }
    pw.close();
    log.info(&quot;cookies已保存&quot;);
}
public void readCookies(String filename) {
    loginCookies.clear();
    try {
        FileInputStream fis
                = new FileInputStream(filename);
        InputStreamReader isr
                = new InputStreamReader(fis);
        BufferedReader br
                = new BufferedReader(isr);
        String str = null;
        while ((str = br.readLine()) != null) {
            int index = str.indexOf(&quot;=&quot;);
            loginCookies.put(
                    str.substring(0, index),
                    str.substring(index + 1, str.length())
            );
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
    log.info(loginCookies);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从文件读取cookie登录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public boolean loginBySavedCookies() {
    readCookies(&quot;zhihu_cookies.txt&quot;);
    con = Jsoup.connect(&quot;https://www.zhihu.com&quot;);//获取连接
    con.header(&quot;User-Agent&quot;, userAgent);//配置模拟浏览器
    con.cookies(loginCookies);
    try {
        rs = con.execute();
    } catch (Exception e) {
        log.info(&quot;读取Cookie登录失败&quot;);
        return false;
    }
    Document doc = Jsoup.parse(rs.body());
    if (checkLogin(doc))
        return true;
    log.info(&quot;读取cookie登录失败,下面手动登录:&quot;);
    return login();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，一个简单的模拟登录程序就完成了&lt;/p&gt;
</description>
        <pubDate>Sat, 23 Jan 2016 00:00:00 +0000</pubDate>
        <link>fdgdfgfdg/blog/2016/01/23/jsoup-learning-note-3/</link>
        <guid isPermaLink="true">fdgdfgfdg/blog/2016/01/23/jsoup-learning-note-3/</guid>
        
        <category>java</category>
        
        <category>jsoup</category>
        
        <category>html</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>jsoup学习笔记(二):读取知乎个人首页动态</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在使用一段时间jsoup后，不满足仅仅处理一些本地文件，因知乎上不提供特别关注某位答主的功能，所以准备慢慢写一个监控动态的工具&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;jsoupurl&quot;&gt;jsoup从url加载网页&lt;/h4&gt;

&lt;p&gt;使用jsoup的connect方法，但注意&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;要在消息头内添加user-agent信息，用来模拟浏览器&lt;/li&gt;
  &lt;li&gt;合理设置timeout数值，防止异常&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Connection con = Jsoup.connect(&quot;https://www.zhihu.com/people/rednaxelafx&quot;);//获取连接
con.header(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:29.0) Gecko/20100101 Firefox/29.0&quot;);//配置模拟浏览器
con.timeout(3000);
Connection.Response rs = con.execute();//拿到返回的response信息
Document doc = Jsoup.parse(rs.body());//得到目标url的dom结构&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;execute方法会抛出IOException，注意用try-catch语句包住或throws掉&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;dom&quot;&gt;分析网页dom结构，编写对应的解析方法&lt;/h4&gt;

&lt;p&gt;首先观察dom结构
&lt;img src=&quot;http://7xq9w1.com1.z0.glb.clouddn.com/2016-01-16-jsoup-learning-note-2-1.jpg&quot; alt=&quot;知乎个人动态的dom结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发现个人动态都是包裹在 &lt;em&gt;class=”zm-profile-section-item zm-item clearfix”&lt;/em&gt; 的div内的&lt;/p&gt;

&lt;p&gt;而 &lt;em&gt;data-time&lt;/em&gt; 属性内的值稍有编程经验的人都可看出是unix时间戳，分析其是该条动态的时间信息&lt;/p&gt;

&lt;p&gt;据此可以拿到当前页的个人动态的dom集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Elements elmts = doc.select(&quot;.zm-profile-section-item.zm-item.clearfix&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进行遍历后遍可输出本次请求获取的所有个人动态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//使用SimpleDateFormat格式化unix时间戳
SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;);
for (Element elmt : elmts) {
	System.out.println(sdf.format(new java.util.Date(Long.parseLong(elmt.attr(&quot;data-time&quot;)) * 1000)));
	System.out.println(elmt.select(&quot;.zm-profile-activity-page-item-main&quot;).text() + &quot;www.zhihu.com&quot; + elmt.select(&quot;.question_link&quot;).attr(&quot;href&quot;));
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码块内，个人动态的url是使用 &lt;em&gt;baseUrl+quetion_link&lt;/em&gt; 形式拼起来的，也可以使用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;elmt.select(&quot;.question_link&quot;).attr(&quot;abs:href&quot;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有的时候直接使用 &lt;em&gt;abs:href&lt;/em&gt; 读取不到正确的绝对地址，这时候需要在document处指定baseUrl:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;doc.setBaseUri(&quot;https://www.zhihu.com&quot;);
...
elmt.select(&quot;.question_link&quot;).attr(&quot;abs:href&quot;);//这时候读取到的就是正确的url了
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在就可以读取某人首页地址并输出他的动态信息了&lt;/p&gt;

&lt;p&gt;但是会发现一个问题，未登录用户（显然上文用jsoup访问url属于未登录）在访问某人首页时会存在延迟（即他的最新动态不能及时获取），延迟时间大概是10~20分钟&lt;/p&gt;

&lt;p&gt;而已登录用户（如在浏览器内登录）刷新某人首页则是实时显示他的动态&lt;/p&gt;

&lt;p&gt;推测是知乎为了防止爬虫频繁刷取页面&lt;/p&gt;

&lt;p&gt;下一步就是用jsoup模拟登录了！&lt;/p&gt;

</description>
        <pubDate>Tue, 19 Jan 2016 00:00:00 +0000</pubDate>
        <link>fdgdfgfdg/blog/2016/01/19/jsoup-learning-note-2/</link>
        <guid isPermaLink="true">fdgdfgfdg/blog/2016/01/19/jsoup-learning-note-2/</guid>
        
        <category>java</category>
        
        <category>jsoup</category>
        
        <category>html</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>jsoup学习笔记(一):一个简单的html处理工具</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;因最近在开发中需要对网页做特定处理，如px转为rem、类名的替换、class转为id、对某class进行排序等。
虽然用java里String的一些方法如正则替换等也能做到，但是会非常繁琐，所以抽出时间学习一下html解析器:jsoup，
然后写了一个小小的工具&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;jsoup&quot;&gt;什么是jsoup&lt;/h3&gt;
&lt;p&gt;jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/jhy/jsoup&quot;&gt;jsoup的github地址&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;如何使用&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;使用jsoup要求你有一定的html、css知识&lt;/em&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-1&quot;&gt;1、从文件解析一个页面&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;Document doc=Jsoup.parse(new File(&quot;something&quot;),&quot;utf-8&quot;);//Document是一个装载html的文档类
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-2&quot;&gt;2、选择器&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;Elements elmt=doc.select(&quot;selector&quot;); //与css选择器语法一致
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-3&quot;&gt;3、常用方法&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;elmt.removeClass(&quot;className&quot;);   //删除指定的class
elmt.attr(&quot;id&quot;,&quot;wtf&quot;);           //添加属性
elmt.removeAttr(&quot;class&quot;);        //删除属性
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有时候我们需要对整个dom树做一次遍历，这时候可以通过NodeVisitor来遍历&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface NodeVisitor {
    //遍历到节点开始时，调用此方法
    public void head(Node node, int depth);
    //遍历到节点结束时(所有子节点都已遍历完)，调用此方法
    public void tail(Node node, int depth);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法还有很多，大多数都能见名知意，就不一一列举了
&lt;strong&gt;&lt;a href=&quot;http://jsoup.org/apidocs/&quot;&gt;jsoup的api&lt;/a&gt;&lt;/strong&gt;
具体例子见下文我的小demo&lt;/p&gt;

&lt;h3 id=&quot;demo&quot;&gt;一个简单的小demo&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;最近在调整html模版中遇到了这么几个需求&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;classidclassclass&quot;&gt;需求一：将指定的class属性替换为id属性,若替换后class属性为空，将class属性删除&lt;/h5&gt;
&lt;p&gt;一个很简单的功能，但如果纯用java String来做的话会相对很繁琐&lt;/p&gt;

&lt;p&gt;用jsoup就很方便了，先用选择器选出指定的class组，对其遍历，删除原class，再添加同名的id属性即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void classConvertToId(String className,String idName){
        Elements elmts=doc.select(className);
        for(Element elmt:elmts){
            elmt.removeClass(className.replaceAll(&quot;\\.|#&quot;,&quot;&quot;));
            elmt.attr(&quot;id&quot;,idName.replaceAll(&quot;\\.|#&quot;,&quot;&quot;));
            if(elmt.attr(&quot;class&quot;).isEmpty())
                elmt.removeAttr(&quot;class&quot;);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是不是很简单呢，有点类似js的风格了&lt;/p&gt;

&lt;h5 id=&quot;stylepxrem&quot;&gt;需求二：将页面内所有元素style属性内长度单位px转换为rem&lt;/h5&gt;
&lt;blockquote&gt;
  &lt;p&gt;因美工给我们的页面是以px为单位，而为了适配页面在不同尺寸设备上的效果，需要使用rem单位，因此产生此需求&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里就要用到上文提到的NodeVisitor了&lt;/p&gt;

&lt;p&gt;使用NodeVisitor和NodeTraversor进行遍历&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NodeVisitor visitor=new NodeVisitor() {
            @Override
            public void head(Node node, int i) {
                if (node.attr(&quot;style&quot;) != null &amp;amp;&amp;amp; !node.attr(&quot;style&quot;).isEmpty()) {
                    StringBuffer sb = new StringBuffer(node.attr(&quot;style&quot;));
			//doSomething here
                }
            }
        };
NodeTraversor tarversor=new NodeTraversor(visitor);
tarversor.traverse(doc);
		
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;顺便提一下，NodeTraversor的遍历是深度优先，核心代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public void traverse(Node root) {
    Node node = root;
    int depth = 0;
    while (node != null) {
        visitor.head(node, depth);
        if (node.childNodeSize() &amp;gt; 0) {
            node = node.childNode(0);
            depth++;
        } else {
            //退栈
            while (node.nextSibling() == null &amp;amp;&amp;amp; depth &amp;gt; 0) {
                visitor.tail(node, depth);
                node = node.parent();
                depth--;
            }
            //结束遍历
            visitor.tail(node, depth);
            if (node == root)
                break;
            node = node.nextSibling();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了扯回来，在遍历的过程中拿到元素style属性的内容(如果有的话)，然后查找内容中是否存在需要转换的值&lt;/p&gt;

&lt;p&gt;替换函数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void replaceByTarget(String startTarget,String endTarget,StringBuffer sb){
                pxStartIndex=0;
                pxEndIndex=0;
                while(pxEndIndex!=-1){
                    pxEndIndex=sb.indexOf(endTarget,pxEndIndex+1);
                    pxStartIndex=sb.lastIndexOf(startTarget,pxEndIndex)+1;
                    if(pxEndIndex!=-1){
                        try{
                            pxNum = Double.parseDouble(sb.substring(pxStartIndex, pxEndIndex).trim());
                        }catch(NumberFormatException e){
                            continue;
                        }
                        double remNum=pxNum/multiple;	//将px转换为rem，multiple为转换系数
                        sb.replace(pxStartIndex, pxEndIndex+2, remNum+&quot;rem&quot;);
                        pxStartIndex=0;
                        pxEndIndex=0;
                    }
                }
            }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，这个需求功能基本就实现了&lt;/p&gt;

&lt;p&gt;完整代码可以移步到我的github上:
&lt;strong&gt;&lt;a href=&quot;https://github.com/PorUnaCabeza/CabezaUtil/blob/master/src/util/HtmlModelUtil.java&quot;&gt;cabezaUtil&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 14 Jan 2016 00:00:00 +0000</pubDate>
        <link>fdgdfgfdg/blog/2016/01/14/jsoup-learning-note-1/</link>
        <guid isPermaLink="true">fdgdfgfdg/blog/2016/01/14/jsoup-learning-note-1/</guid>
        
        <category>java</category>
        
        <category>jsoup</category>
        
        <category>html</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>博客搬迁</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;博客搬迁&lt;/h2&gt;

&lt;p&gt;近期将以往博客搬迁过来&lt;/p&gt;
</description>
        <pubDate>Sun, 03 Jan 2016 00:00:00 +0000</pubDate>
        <link>fdgdfgfdg/blog/2016/01/03/init-blog/</link>
        <guid isPermaLink="true">fdgdfgfdg/blog/2016/01/03/init-blog/</guid>
        
        <category>生活</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>使用java写个简单游戏脚本（二）：JNI</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;上一次的小程序只是演示了一下如何用robot类控制鼠标键盘操作&lt;/p&gt;

  &lt;p&gt;这种方法有很大的弊端：1、不能后台运行。2、坐标代码写死，窗口甚至都不可移动。3、某些游戏会屏蔽该类
下面讲述下如何用JNI技术实现游戏内脚本后台执行&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;jni&quot;&gt;什么是JNI&lt;/h3&gt;
&lt;p&gt;简单讲就是实现了java和其他语言的通信，下面要用到是c或c++&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://baike.baidu.com/link?url=CMSZ7ybpBNF4ajNimLQfbiNAJXZS-66dLhw98oK1S6cJpwN9yMxZ-7weEuzx05nvFGY19bLXHR2AAFbdeo2C1K&quot;&gt;JNI&lt;/a&gt;自行阅读，不赘述&lt;/p&gt;

&lt;p&gt;&lt;em&gt;另：不到万不得已不要使用JNI，一方面它需要你掌握更多的知识才可以驾驭，一方面使用了JNI你的程序就会丧失可移植性&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;jni-1&quot;&gt;为什么要用JNI&lt;/h3&gt;
&lt;p&gt;java本身无法获得windows的接口，如窗口句柄等，需要借助c或c++&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;java代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
public class TowerUtil {
	public static native void keyPress(int hwnd, int key);
	public static native void mouseClick(int hwnd,int x,int y);
	static{
		System.loadLibrary(&quot;towerutil&quot;);
	}
	public static void main(String[] args) {
        int hwnd=1050990;
		TowerUtil.keyPress(hwnd, 0x42); 
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意keyPress和mouseClick函数的声明，它有一个关键字native，表明这个方法使用java以外的语言实现。方法不包括实现，因为我们要用c/c++语言实现它&lt;/p&gt;

&lt;p&gt;System.loadLibrary(“towerutil”)这句代码，在静态初始化块中定义的，用来装载towerutil.dll动态链接库&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;编译生成头文件&lt;/h3&gt;
&lt;p&gt;使用命令javah:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;javah TowerUtil.java&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文件内容如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
/* DO NOT EDIT THIS FILE - it is machine generated */
#include &quot;jni.h&quot;
/* Header for class TowerUtil */

#ifndef _Included_TowerUtil
#define _Included_TowerUtil
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
/*
 * Class:     TowerUtil
 * Method:    keyPress
 * Signature: (II)V
 */
JNIEXPORT void JNICALL Java_TowerUtil_keyPress
  (JNIEnv *, jclass, jint, jint);

/*
 * Class:     TowerUtil
 * Method:    mouseClick
 * Signature: (III)V
 */
JNIEXPORT void JNICALL Java_TowerUtil_mouseClick
  (JNIEnv *, jclass, jint, jint, jint);

#ifdef __cplusplus
}
#endif
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;cc&quot;&gt;用c/c++实现函数体&lt;/h3&gt;
&lt;p&gt;第三部里定义了keyPress和mouseClick两个函数，接下来要用c语言实现它，注意观察上一步生成的头文件里的函数名和参数，按照其来写
如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &quot;stdafx.h&quot;
#include &quot;jni.h&quot;
#include &quot;TowerUtil.h&quot;

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    return TRUE;
}
JNIEXPORT void JNICALL Java_TowerUtil_mouseClick
(JNIEnv *env, jobject obj, jint hwnd, jint x, jint y){
	LPARAM lparam = MAKELPARAM(x,y);
	SendMessage((HWND)hwnd, WM_LBUTTONDOWN, MK_LBUTTON, lparam);
	sleep(10);
	SendMessage((HWND)hwnd, WM_LBUTTONUP, MK_LBUTTON, lparam);
	return;
}
JNIEXPORT void JNICALL Java_TowerUtil_keyPress
  (JNIEnv *env, jobject obj, jint hwnd, jint key){
	SendMessage((HWND)hwnd,WM_KEYDOWN,key,0);
	sleep(100);
	SendMessage((HWND)hwnd,WM_KEYUP,key,0);
	return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于代码里出现的SendMessage函数:&lt;a href=&quot;http://jingyan.baidu.com/article/c45ad29cd5fb58051653e278.html&quot;&gt;SendMessage 函数参数大全&lt;/a&gt; 的
注意在开头引入jni.h和前面生成的TowerUtil.h
### 生成dll文件
下面生成前面提到的 towerutil.dll，windows可以下载MinGW进行编译:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;gcc -shared TowerUtil.cpp -o towerutil.dll -I （.h头文件目录）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;java-1&quot;&gt;运行java程序&lt;/h3&gt;
&lt;p&gt;把上面生成的dll文件加入到java.library.path内&lt;/p&gt;

&lt;p&gt;main函数里写上一行：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TowerUtil.keyPress(hwnd, 0x42);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;解释下， hwnd是我玩的完美国际当前的句柄值，0x42是键盘“b”的asiic值，游戏内b键打开背包
执行后可以看到游戏里的背包界面打开
大功告成！
再结合上一篇文章写到的脚本解析函数的思路，就可以写出一个略微简陋的游戏脚本执行器了
使用JNI的好处上面已提到，脚本编写好后，你可以把游戏最小化，也不影响执行
如果能够再获得游戏内属性基址，就能写出一个功能更丰富的??了&lt;/p&gt;
</description>
        <pubDate>Wed, 09 Sep 2015 00:00:00 +0000</pubDate>
        <link>fdgdfgfdg/blog/2015/09/09/use-java-for-game-script/</link>
        <guid isPermaLink="true">fdgdfgfdg/blog/2015/09/09/use-java-for-game-script/</guid>
        
        <category>java</category>
        
        <category>游戏</category>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
