<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Namárië</title>
    <description></description>
    <link>cabeza.cn/</link>
    <atom:link href="cabeza.cn/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 10 Jul 2016 13:10:25 +0000</pubDate>
    <lastBuildDate>Sun, 10 Jul 2016 13:10:25 +0000</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>自己搭建服务器造梯子的小记</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在学校时曾申请过github education pack，前段时间收到成功的邮件，仔细看了下，学生礼包里包含DigitalOcean的50刀代金券，拿来搞个VPS装上shadowsocks是极好的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;github-education&quot;&gt;Github education&lt;/h4&gt;

&lt;p&gt;在填写一些个人信息、申请理由，上传学生证明（如学生证）后，将会得到一个Student Developer大礼包，其中包括aws、digitalocean等的代金券&lt;/p&gt;

&lt;h4 id=&quot;digital-ocean&quot;&gt;Digital Ocean&lt;/h4&gt;

&lt;p&gt;注册账号并登录后，切换到billing界面，在此处即可使用学生礼包里提供的DigitalOcean 50美刀代金券，需要注意的是，需要绑定信用卡或者先向账户里充值5美刀
才可以激活账号，我是选择使用Paypal充了5美刀。&lt;/p&gt;

&lt;p&gt;激活后，使用代金券，账户内余额变成了55美刀，搭建5美刀的vps话，够用11个月了&lt;/p&gt;

&lt;p&gt;在创建vps时选择5$/month的那款，机房建议选择旧金山或者纽约，系统的话建议选择Centos（6版本），为之后的安装加速工具提供方便&lt;/p&gt;

&lt;h4 id=&quot;shadowsocks&quot;&gt;Shadowsocks&lt;/h4&gt;

&lt;p&gt;远程登陆上主机后，便可以进行配置了
(需要一定linux基础)&lt;/p&gt;

&lt;h5 id=&quot;section&quot;&gt;安装&lt;/h5&gt;

&lt;p&gt;Debian / Ubuntu:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt-get install python-pip
pip install shadowsocks
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;CentOS:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum install python-setuptools &amp;amp;&amp;amp; easy_install pip
pip install shadowsocks
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-1&quot;&gt;配置&lt;/h5&gt;

&lt;p&gt;新建一个json文件，如/etc/shadowsocks.json&lt;/p&gt;

&lt;p&gt;内容为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;server&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;你的服务器ip地址&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;server_port&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8388&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;local_address&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;local_port&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1080&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;你设置的密码&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;timeout&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;method&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;aes-256-cfb&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;fast_open&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-2&quot;&gt;启动&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssserver -c /etc/shadowsocks.json
#或者在后台运行
ssserver -c /etc/shadowsocks.json -d start
ssserver -c /etc/shadowsocks.json -d stop
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-3&quot;&gt;锐速&lt;/h4&gt;

&lt;p&gt;我的服务器是选择在旧金山，在没装加速软件的情况下，看youtube480p卡顿，经测试网速在100k左右，实在不能忍。&lt;/p&gt;

&lt;p&gt;不同于finalspeed，锐速是一款单边加速工具，具体细节可以google&lt;/p&gt;

&lt;h5 id=&quot;section-4&quot;&gt;安装&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;以下背景均是Centos6，ubuntu自行google&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、更换内核版本&lt;/p&gt;

&lt;p&gt;在DigitalOcean后台，将内核更换为2.6.32-504.3.3.el6.x86_64&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果不是DigitalOcean的服务器，使用
rpm -ivh http://soft.91yun.org/ISO/Linux/CentOS/kernel/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm
rpm -ivh http://soft.91yun.org/ISO/Linux/CentOS/kernel/kernel-2.6.32-504.3.3.el6.x86_64.rpm --force
来更换，重启，执行uname -r命令查看结果
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2、安装锐速破解版&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh &amp;amp;&amp;amp; bash serverspeeder-all.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;卸载方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;chattr -i /serverspeeder/etc/apx* &amp;amp;&amp;amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此，基本结束&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;一些常用命令&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#查看锐速状态
/serverspeeder/bin/serverSpeeder.sh status
#查看当前使用本机shadosocks服务的ip
netstat -an | grep 8388（你的端口） | grep ESTABLISHED
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;粗略的做了下记录，以后有空再补充&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Jul 2016 00:00:00 +0000</pubDate>
        <link>cabeza.cn/blog/2016/07/10/digital-ocean-vps-establish/</link>
        <guid isPermaLink="true">cabeza.cn/blog/2016/07/10/digital-ocean-vps-establish/</guid>
        
        <category>vps</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>爬虫数据去重小记</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;最近把之前写的知乎爬虫做了些调整，在数据去重这块遇到了点问题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;写毕设之余将知乎爬虫算是重写了一遍，会依次抓取各用户关注的人信息，数据量呈指数级递增，因为用户的关注是交叉式的，不可避免的会遇到数据去重的问题&lt;/p&gt;

&lt;p&gt;到目前为止，我抓取了15.8万条用户信息，1141.3万条用户之间关系信息，我只对这15.8万用户的url进行去重，按道理讲用一个HashSet就可以了，
无奈阿里云服务器内存是1G的，用HashSet加载后就报&lt;em&gt;CodeCache is full&lt;/em&gt;错误，只好再研究别的去重方式喽&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;哈希表&lt;/h4&gt;

&lt;p&gt;平常用的最多的就是它，没啥讲的，简单快速准确，缺点是比较废空间，当集合比较小时这个问题不显著，但是当集合巨大时，哈希表存储效率低的问题就显现出来了。&lt;/p&gt;

&lt;p&gt;比如说，一个象 Yahoo,Hotmail 和 Gmai 那样的公众电子邮件（email）提供商，总是需要过滤来自发送垃圾邮件的人（spamer）的垃圾邮件。
一个办法就是记录下那些发垃圾邮件的 email 地址。由于那些发送者不停地在注册新的地址，全世界少说也有几十亿个发垃圾邮件的地址，
将他们都存起来则需要大量的网络服务器。如果用哈希表，每存储一亿 个 email 地址， 就需要 1.6GB 的内存（用哈希表实现的具体办法是将每一个 email 地址对应成一个八字节的信息指纹）
然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有 50%，因此一个 email 地址需要占用十六个字节。一亿个地址大约要 1.6GB， 即十六亿字节的内存）。
因此存贮几十亿个邮件地址可能需要上百 GB 的内存。除非是超级计算机，一般服务器是无法存储的。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;布隆过滤器&lt;/h4&gt;

&lt;p&gt;它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率（Bloom Filter报告某一元素存在于某集合中，但是实际上该元素并不在集合中）
和删除困难，但是没有识别错误的情形（某个元素确实在该集合中，那么Bloom Filter 是不会报告该元素不存在于集合中的，所以不会漏报）。&lt;/p&gt;

&lt;p&gt;直接上代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class BloomFilter {

	private static final int DEFAULT_SIZE = 2 &amp;lt;&amp;lt; 24;//比特长度
	private static final int[] seeds = {3,5,7, 11, 13, 31, 37, 61};
	private static BitSet bits = new BitSet(DEFAULT_SIZE);
	private static SimpleHash[] func = new SimpleHash[seeds.length];

	public static void add(String value)
	{
		if(value != null){
			for(SimpleHash f : func)
				bits.set(f.hash(value),true);
		}
	}

	public static boolean contains(String value)
	{
		if(value == null) return false;
		boolean ret = true;
		for(SimpleHash f : func){
			if(!bits.get(f.hash(value)))
				return false;
		}
		return true;
	}
}

class SimpleHash {

	private int cap;
	private int seed;

	public  SimpleHash(int cap, int seed) {
		this.cap = cap;
		this.seed = seed;
	}

	public int hash(String value) {
		int result = 0;
		int len = value.length();
		for (int i = 0; i &amp;lt; len; i++) {
			result = seed * result + value.charAt(i);
		}
		return (cap - 1) &amp;amp; result;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;布隆过滤器需要的是一个位数组（这个和位图有点类似）和k个映射函数（和Hash表类似），在初始状态时，对于长度为m的位数组array，
它的所有位都被置为0。对于有n个元素的集合S={s1,s2……sn}，通过k个映射函数{f1,f2,……fk}，将集合S中的每个元素sj(1&amp;lt;=j&amp;lt;=n)映射为k个值{g1,g2……gk}，
然后再将位数组array中相对应的array[g1],array[g2]……array[gk]置为1；如果要查找某个元素item是否在S中，
则通过映射函数{f1,f2…..fk}得到k个值{g1,g2…..gk}，然后再判断array[g1],array[g2]……array[gk]是否都为1，若全为1，则item在S中，
否则item不在S中。这个就是布隆过滤器的实现原理。&lt;/p&gt;

&lt;h4 id=&quot;redis&quot;&gt;redis去重&lt;/h4&gt;

&lt;p&gt;最近才尝试使用redis（以前项目都是玩具，也用不到），感觉真好用啊，现在新写东西都在想“这个要不要引入redis呢”哈哈&lt;/p&gt;

&lt;p&gt;redis去重我是用的set数据格式，简单易懂，最常见，直接把要去重的数据sadd，需要计数就scard&lt;/p&gt;

&lt;p&gt;简单的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public static boolean put(String value){
    if(jedis.sismember(FILTER_NAME,value)){
        return true;//存在
    }else{
        jedis.sadd(FILTER_NAME,value);
        return false;//不存在并添加
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因为我的爬虫里待爬取列表也是用的redis，这样就太方便后台做一些交集、差集的运算，用起来很爽&lt;/p&gt;

&lt;p&gt;当然这是最简单的用法，还有基于zset、redis+lua脚本实现布隆过滤器等更强大的数据去重&lt;/p&gt;

&lt;p&gt;可以翻阅  &lt;a href=&quot;http://www.csdn.net/article/a/2016-03-16/15836359&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;漫谈redis在运维数据分析中的去重统计方式&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 28 Apr 2016 00:00:00 +0000</pubDate>
        <link>cabeza.cn/blog/2016/04/28/crawlers-data-deduplication/</link>
        <guid isPermaLink="true">cabeza.cn/blog/2016/04/28/crawlers-data-deduplication/</guid>
        
        <category>html</category>
        
        <category>java</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Datatables学习小记</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;最近在自己写的一些玩具内经常要用到表格，在用html+jquery实现了一些后，深感麻烦，于是便找了一个插件来用用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前段时间，写了几个统计游戏信息的网页：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://cabeza.cn/pw.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;统计游戏内角色物品&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://cabeza.cn/tianzun.html&quot;&gt;&lt;strong&gt;天尊区顶级角色统计&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;里面都涉及到很多表格的操作，我都是用jquery来简单操纵，对于这样功能不复杂的网页已经足够&lt;/p&gt;

&lt;p&gt;但是最近写的几个页面要设计大量关于表格的操作，于是便找了个jquery表格插件Datatables来用用&lt;/p&gt;

&lt;h3 id=&quot;datatables&quot;&gt;关于Datatables&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://datatables.club/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Datatables中文网&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://datatables.net/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Datatables官网&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;起步&lt;/h3&gt;

&lt;p&gt;你需要&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;引入Datatables的js和css文件&lt;/li&gt;
  &lt;li&gt;在html内画一个table&lt;/li&gt;
  &lt;li&gt;执行$(‘table的选择器’).datatable();&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;参考：&lt;a href=&quot;http://datatables.club/manual/install.html&quot; target=&quot;_blank&quot;&gt;Datatables的安装&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;根据服务器返回的数据初始化表格&lt;/h3&gt;

&lt;p&gt;Datatables使用的数据源必须是一个数组，数组里的每一项将显示在你定义的行上面，
datatables可以使用三种基本的javascript数据类型来作为数据源：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数组(Arrays [])&lt;/li&gt;
  &lt;li&gt;对象(objects {})&lt;/li&gt;
  &lt;li&gt;实例(new myclass())&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面说下用的比较多的从对象初始化&lt;/p&gt;

&lt;p&gt;对象格式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var vehicleData=
	[
		{
			&quot;id&quot;:&quot;12&quot;,
			&quot;plateNumber&quot;:&quot;苏A0651&quot;,
			&quot;ownerName&quot;:&quot;张全蛋&quot;,
			&quot;ownerTel&quot;:&quot;233&quot;,
			&quot;ownerIdNumber&quot;:&quot;9527&quot;,
			&quot;ownerAddress&quot;:&quot;南京&quot;
		},
		{
			&quot;id&quot;:&quot;13&quot;,
			&quot;plateNumber&quot;:&quot;苏B001&quot;,
			&quot;ownerName&quot;:&quot;唐马儒&quot;,
			&quot;ownerTel&quot;:&quot;344&quot;,
			&quot;ownerIdNumber&quot;:&quot;1234&quot;,
			&quot;ownerAddress&quot;:&quot;南京&quot;
		}
	]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;html：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;table id=&quot;vehicleTable&quot;&amp;gt;
	&amp;lt;thead&amp;gt;
		&amp;lt;tr&amp;gt;
			&amp;lt;th&amp;gt;&amp;lt;/th&amp;gt;
			&amp;lt;th&amp;gt;&amp;lt;/th&amp;gt;
			&amp;lt;th&amp;gt;&amp;lt;/th&amp;gt;
			&amp;lt;th&amp;gt;&amp;lt;/th&amp;gt;
			&amp;lt;th&amp;gt;&amp;lt;/th&amp;gt;
			&amp;lt;th&amp;gt;&amp;lt;/th&amp;gt;
			&amp;lt;th&amp;gt;&amp;lt;/th&amp;gt;
		&amp;lt;/tr&amp;gt;
	&amp;lt;/thead&amp;gt;
	&amp;lt;tbody&amp;gt;

	&amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建表格：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(&#39;#vehicleTable&#39;).dataTable({
    data:vehicleData,
    columnDefs: [
        {
            targets: 0,
            data:&#39;id&#39;,
            title:&#39;id&#39;
        },
        {
            targets:1,
            data:&#39;plateNumber&#39;,
            title:&#39;车牌&#39;
        },
        {
            targets:3,
            data:&#39;ownerName&#39;,
            title:&#39;车主&#39;
        },
        {
            targets:4,
            data:&#39;ownerTel&#39;,
            title:&#39;电话&#39;
        },
        {
            targets:5,
            data:&#39;ownerIdNumber&#39;,
            title:&#39;车主身份证&#39;
        },
        {
            targets:6,
            data:&#39;ownerAddress&#39;,
            title:&#39;地址&#39;
        }
    ]
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用&lt;kbd&gt;columnDefs&lt;/kbd&gt;参数给列定义，使用&lt;kbd&gt;targets&lt;/kbd&gt;告诉这个定义是指向哪一列
&lt;kbd&gt;data&lt;/kbd&gt;用来设置列的数据源，&lt;kbd&gt;title&lt;/kbd&gt;设定该列的标题。&lt;/p&gt;

&lt;p&gt;有些数据不希望显示在屏幕上，或者需要什么条件才会显示，可以使用&lt;kbd&gt;visible&lt;/kbd&gt;选项来控制&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;targets:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;0,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;data:&#39;id&#39;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;title:&#39;id&#39;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;visible:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一般来讲，隐藏时也要禁止该数据参与排序与搜索：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;targets:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;0,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;data:&#39;id&#39;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;title:&#39;id&#39;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;visible:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;false,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;searchable:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;false，&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;orderable:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，一张表格就会展示出来了&lt;/p&gt;

&lt;p&gt;&lt;em&gt;此处仅展示外观仅是表格主体部分，因为一些原因不便于加载js，并不能实现全部功能，&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;一个完整的Datatables表格 &lt;a href=&quot;http://datatables.club/example/basic_init/flexible_width.html&quot;&gt;&lt;strong&gt;例子&lt;/strong&gt;&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;table id=&quot;vehicleTable&quot; class=&quot;table&quot;&gt;
	&lt;thead&gt;
		&lt;tr role=&quot;row&quot;&gt;
			&lt;th class=&quot;sorting&quot; rowspan=&quot;1&quot; colspan=&quot;1&quot;&gt;车牌&lt;/th&gt;
			&lt;th class=&quot;sorting&quot; rowspan=&quot;1&quot; colspan=&quot;1&quot;&gt;车主&lt;/th&gt;
			&lt;th class=&quot;sorting&quot; rowspan=&quot;1&quot; colspan=&quot;1&quot;&gt;电话&lt;/th&gt;
			&lt;th class=&quot;sorting&quot; rowspan=&quot;1&quot; colspan=&quot;1&quot;&gt;车主身份证&lt;/th&gt;
			&lt;th class=&quot;sorting&quot; rowspan=&quot;1&quot; colspan=&quot;1&quot;&gt;地址&lt;/th&gt;
		&lt;/tr&gt;
	&lt;/thead&gt;
	&lt;tbody&gt;
		&lt;tr role=&quot;row&quot; class=&quot;odd&quot;&gt;
			&lt;td&gt;苏A0651&lt;/td&gt;
			&lt;td&gt;张全蛋&lt;/td&gt;
			&lt;td&gt;233&lt;/td&gt;
			&lt;td&gt;9527&lt;/td&gt;
			&lt;td&gt;南京&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr role=&quot;row&quot; class=&quot;odd&quot;&gt;
			&lt;td&gt;苏B001&lt;/td&gt;
			&lt;td&gt;唐马儒&lt;/td&gt;
			&lt;td&gt;344&lt;/td&gt;
			&lt;td&gt;1234&lt;/td&gt;
			&lt;td&gt;南京&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;如果想给每一行增加几个操作按钮,使用&lt;kbd&gt;defaultContent&lt;/kbd&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;columnDefs: 
	[
		//前面的省略
		{
			targets:7,
			data:null,
			searchable:false,
			orderable:false，
			defaultContent:&#39;&amp;lt;button type=&quot;button&quot; class=&quot;btn btn-danger btn-sm vehicle-del&quot;&amp;gt;删除&amp;lt;/button&amp;gt;&#39; +
			&#39;&amp;lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-sm vehicle-update&quot;&amp;gt;更改&amp;lt;/button&amp;gt;&#39;
		}
	]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;table id=&quot;vehicleTable&quot; class=&quot;table&quot;&gt;
	&lt;thead&gt;
		&lt;tr role=&quot;row&quot;&gt;
			&lt;th class=&quot;sorting&quot; rowspan=&quot;1&quot; colspan=&quot;1&quot;&gt;车牌&lt;/th&gt;
			&lt;th class=&quot;sorting&quot; rowspan=&quot;1&quot; colspan=&quot;1&quot;&gt;车主&lt;/th&gt;
			&lt;th class=&quot;sorting&quot; rowspan=&quot;1&quot; colspan=&quot;1&quot;&gt;电话&lt;/th&gt;
			&lt;th class=&quot;sorting&quot; rowspan=&quot;1&quot; colspan=&quot;1&quot;&gt;车主身份证&lt;/th&gt;
			&lt;th class=&quot;sorting&quot; rowspan=&quot;1&quot; colspan=&quot;1&quot;&gt;地址&lt;/th&gt;
			&lt;th class=&quot;sorting&quot; rowspan=&quot;1&quot; colspan=&quot;1&quot;&gt;操作&lt;/th&gt;
		&lt;/tr&gt;
	&lt;/thead&gt;
	&lt;tbody&gt;
		&lt;tr role=&quot;row&quot; class=&quot;odd&quot;&gt;
			&lt;td&gt;苏A0651&lt;/td&gt;
			&lt;td&gt;张全蛋&lt;/td&gt;
			&lt;td&gt;233&lt;/td&gt;
			&lt;td&gt;9527&lt;/td&gt;
			&lt;td&gt;南京&lt;/td&gt;
			&lt;td&gt;
				&lt;button type=&quot;button&quot; class=&quot;btn btn-danger btn-sm vehicle-del&quot; vehicleid=&quot;12&quot; index=&quot;0&quot;&gt;删除&lt;/button&gt;
				&lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-sm vehicle-update&quot; vehicleid=&quot;12&quot; index=&quot;0&quot;&gt;更改&lt;/button&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr role=&quot;row&quot; class=&quot;odd&quot;&gt;
			&lt;td&gt;苏B001&lt;/td&gt;
			&lt;td&gt;唐马儒&lt;/td&gt;
			&lt;td&gt;344&lt;/td&gt;
			&lt;td&gt;1234&lt;/td&gt;
			&lt;td&gt;南京&lt;/td&gt;
			&lt;td&gt;
				&lt;button type=&quot;button&quot; class=&quot;btn btn-danger btn-sm vehicle-del&quot; vehicleid=&quot;12&quot; index=&quot;0&quot;&gt;删除&lt;/button&gt;
				&lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-sm vehicle-update&quot; vehicleid=&quot;12&quot; index=&quot;0&quot;&gt;更改&lt;/button&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;我们是需要根据按钮执行一些操作的，因为按钮是动态添加上的，所以监听的绑定要放在回调函数里&lt;/p&gt;

&lt;h4 id=&quot;rowcallbackbuttonid&quot;&gt;通过rowCallback回调函数为每一个button添加数据的id&lt;/h4&gt;

&lt;p&gt;在每一行绘制后，会调用该函数，其包含三个参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;row：该行的dom元素&lt;/li&gt;
  &lt;li&gt;data：该行的源数据&lt;/li&gt;
  &lt;li&gt;index: 该行的序列&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在dataTable方法内可以这样写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;columnDefs: [
	//前面的省略
	rowCallback:function( row, data, index ){
		var id=data.id;
		$(&#39;td&#39;,row).last().find(&#39;button&#39;).attr(&#39;vehicleId&#39;,id).attr(&quot;index&quot;,index);
	}
]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;drawcallback&quot;&gt;在drawCallback回调函数内绑定监听&lt;/h4&gt;

&lt;p&gt;当每次表格重绘的时候触发drawCallback，比如更新数据后或者创建新的元素&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;drawCallback:function(){
        $(&#39;.vehicle-del&#39;).click(function(){
           dosomethig
        });
        $(&#39;.vehicle-update&#39;).click(function(){
           dosomethig 
        });
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;apirowrowdata&quot;&gt;进阶：使用api内提供的row()与row().data()实现上文功能&lt;/h3&gt;

&lt;p&gt;使用两个回调函数来实现一个简单的功能看起来实在是太蠢了，于是遍访api后我发现了这样一个函数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;row()：Working with rows is a fundamental part of DataTables, and you want to be able to easily select the rows that you want from the table.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;简单来讲，使用row()得到点击事件所发生的行，然后使用row().data()函数拿到该行数据&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(&#39;#vehicleTable tbody&#39;).on(&#39;click&#39;,&#39;button&#39;,function(){
	var tr=$(this).parents(&#39;tr&#39;);
	var rowData=table.api().row(tr).data();
	//此处rowData即该行数据
	dosomethig
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 28 Feb 2016 00:00:00 +0000</pubDate>
        <link>cabeza.cn/blog/2016/02/28/datatable-learning-note-1/</link>
        <guid isPermaLink="true">cabeza.cn/blog/2016/02/28/datatable-learning-note-1/</guid>
        
        <category>JavaScript</category>
        
        <category>Datatables</category>
        
        <category>html</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>jsoup学习笔记(四):监控动态与爬取所有动态</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;今日公司年会，微醺&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在成功登录后，就可以搞一些好玩的事情了&lt;/p&gt;

&lt;p&gt;比如知乎没有提供特别关心某用户的功能，我们可以自己做一个，当关注的用户有新的动态时，发送邮件提醒我们&lt;/p&gt;

&lt;p&gt;或者，爬取某用户的所有动态，来分析他的喜好习惯&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;监控动态&lt;/h3&gt;

&lt;h4 id=&quot;dom&quot;&gt;1、分析dom，提取信息&lt;/h4&gt;

&lt;p&gt;首先分析个人主页的dom结构&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;zm-profile-section-list profile-feed-wrap&quot;&amp;gt;
	&amp;lt;div id=&quot;zh-profile-activity-page-list&quot;&amp;gt;
		&amp;lt;div class=&quot;zm-profile-section-item zm-item clearfix&quot; data-time=&quot;1454573143&quot; data-type=&quot;a&quot; data-type-detail=&quot;member_voteup_answer&quot;&amp;gt;
		...
		&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;具体的结构因为太长不太方便展现，可以到知乎去看下&lt;/p&gt;

&lt;p&gt;经过观察，每一条动态都是在”zm-profile-section-item zm-item clearfix”类中的&lt;/p&gt;

&lt;p&gt;其中data-time为unix时间戳&lt;/p&gt;

&lt;p&gt;接着需要得到该动态的题目&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;zm-profile-section-main zm-profile-section-activity-main zm-profile-activity-page-item-main&quot;&amp;gt;
	赞同了回答
	&amp;lt;a class=&quot;question_link&quot; target=&quot;_blank&quot; href=&quot;/question/36305720/answer/67332034&quot;&amp;gt;如果上古卷轴5成为中学必修课会怎样?&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过select(‘.zm-profile-activity-page-item-main’).text()可以拿到&lt;/p&gt;

&lt;p&gt;该动态的链接 select(“.zm-profile-activity-page-item-main &amp;gt; a”).last().attr(“abs:href”)&lt;/p&gt;

&lt;p&gt;大概是这个样子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Elements elmts = doc.select(&quot;.zm-profile-section-item.zm-item.clearfix&quot;);
    for (Element elmt : elmts) {
		String time=elmt.attr(&quot;data-time&quot;);
		String name=elmt.select(&quot;.zm-profile-activity-page-item-main&quot;).text();
		String href=elmt.select(&quot;.zm-profile-activity-page-item-main &amp;gt; a&quot;).last().attr(&quot;abs:href&quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;2、判断最新动态&lt;/h4&gt;

&lt;p&gt;上面提到data-time内为该动态的unix时间戳，那么记录下当前最新的data-time，在下一次拉取时，用该次的
所有data-time与上一次的最新data-time进行比较，大于上一次的皆为新增动态&lt;/p&gt;

&lt;p&gt;定义一个recentNewsTime记录当前最新data-time&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;recentNewsTime=elmts.get(0).attr(&quot;data-time&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;定义一个updateNews来记录最新动态列表
每次拉取时：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if(elmt.attr(&quot;data-time&quot;).compareTo(recentNewsTime)&amp;gt;0)
	updateNews.put(...);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;3、发送邮件&lt;/h4&gt;

&lt;p&gt;使用javax.mail包来实现，没啥好讲的，看看api就行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void sendMail(Map&amp;lt;String,String&amp;gt; news) {
    Properties props=new Properties();
    try {
        ClassLoader loader = ZhihuUtil.class.getClassLoader();
        InputStream in = loader.getResourceAsStream(&quot;mailConfig.properties&quot;);
        props.load(in);
        System.out.println(props);
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
    Session session = Session.getInstance(props);
    Transport ts = null;
    try {
        ts = session.getTransport();
        ts.connect(props.getProperty(&quot;mail.smtp.host&quot;), props.getProperty(&quot;username&quot;), props.getProperty(&quot;password&quot;));
        MimeMessage message = new MimeMessage(session);
        //发件人
        message.setFrom(new InternetAddress(&quot;makpia@163.com&quot;));
        //收件人
        message.setRecipient(Message.RecipientType.TO, new InternetAddress(&quot;makpia@163.com&quot;));
        message.setSubject(sdf.format(System.currentTimeMillis()) + &quot;有新动态&quot;);
        emailContent.setLength(0);
        for (Map.Entry&amp;lt;String, String&amp;gt; entry : news.entrySet()) {
            date.setTime(Long.parseLong(entry.getKey()) * 1000);
            emailContent.append(sdf.format(date)+entry.getValue()+&quot;&amp;lt;br&amp;gt;&quot;);
        }
        message.setContent(emailContent.toString(), &quot;text/html;charset=UTF-8&quot;);
        ts.sendMessage(message, message.getAllRecipients());
        log.info(&quot;邮件发送成功!&quot;);
    } catch (Exception e) {
        log.info(&quot;发送邮件失败,请检查邮件配置&quot;);
        e.printStackTrace();
    } finally {
        try {
            ts.close();
        } catch (MessagingException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;爬取所有动态&lt;/h3&gt;

&lt;p&gt;跟上文的监控动态很相似，不同的是需要分析点击“更多”时发送的请求与返回的信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;请求url
Request URL:https://www.zhihu.com/people/excited-vczh/activities
Request Method:POST
参数
Form Date:
start:1457128047
_xsrf:00662dfea71523ebea00cebcfca083ff
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;请求的参数中，start指的是点击“更多”时当前展示的最后一条动态的unix时间戳，该值可以从页面dom元素中获取：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;elmts = doc.select(&quot;.zm-profile-section-item.zm-item.clearfix&quot;);
    while(!elmts.isEmpty()){
        for (Element elmt : elmts) {
			//...
            traverseStartSign = elmt.attr(&quot;data-time&quot;);
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;_xsrf在前面文章中提到过，猜测是一种验证机制，用登陆时保存的值即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;con = Jsoup.connect(url + &quot;/activities&quot;).method(Connection.Method.POST).timeout(3000).ignoreContentType(true);//获取连接
        con.header(&quot;User-Agent&quot;, userAgent);//配置模拟浏览器
        con.data(&quot;start&quot;, traverseStartSign).data(&quot;_xsrf&quot;, _xsrf);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再来返回的信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;r&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;msg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;div class=\&quot;zm-profile-section-item zm-item clearfix\&quot; data-time=\&quot;1457128021\&quot; data-type=\&quot;a\&quot; data-type-detail=\&quot;member_voteup_answer\&quot;&amp;gt;\n&amp;lt;span class=\&quot;zm-profile-setion-time zg-gray zg-right\&quot;&amp;gt;7 \u5c0f\u65f6\u524d&amp;lt;\/span&amp;gt;\n....后面东西太多，不展示了&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到返回的是一个json串，其中msg为时间戳start之后的动态信息，&lt;/p&gt;

&lt;p&gt;\uxxxx这种格式是Unicode写法，表示一个字符，例如\u5c0f表示汉语中的‘小’字。&lt;/p&gt;

&lt;p&gt;为了解析json串，需要引入json相关的包&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;JSONObject jsonObj=JSONObject.fromString(rs.body());
doc=Jsoup.parse(jsonObj.getJSONArray(&quot;msg&quot;).get(1).toString());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;得到的doc就是新动态的dom信息，接着像监控动态里分析dom，提取信息即可&lt;/p&gt;

&lt;p&gt;分析得到的dom后，继续判断当前展示的最后一条动态的unix时间戳、发送请求、得到返回的dom结构，如是往复，即可遍历所有动态&lt;/p&gt;

</description>
        <pubDate>Sat, 30 Jan 2016 00:00:00 +0000</pubDate>
        <link>cabeza.cn/blog/2016/01/30/jsoup-learning-note-4/</link>
        <guid isPermaLink="true">cabeza.cn/blog/2016/01/30/jsoup-learning-note-4/</guid>
        
        <category>java</category>
        
        <category>jsoup</category>
        
        <category>html</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>jsoup学习笔记(三):模拟登录</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;如上文所述，未登录状态爬取信息时会有很多限制，那么就来看看如何模拟登录知乎&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;cookie&quot;&gt;采用最暴力的方法：硬塞cookie&lt;/h3&gt;

&lt;p&gt;首先，在浏览器上登录帐号，然后提取到cookie&lt;/p&gt;

&lt;p&gt;关于如何获取，各个浏览器不一样，可以针对自己的百度下&lt;/p&gt;

&lt;p&gt;拿到cookie值后，在程序里硬编码写入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Connection con = Jsoup.connect(&quot;https://www.zhihu.com&quot;);//获取连接
con.header(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:29.0) Gecko/20100101 Firefox/29.0&quot;);//配置模拟浏览器
Map&amp;lt;String, String&amp;gt; cookie = new HashMap&amp;lt;&amp;gt;();
cookie.put(&quot;_xsrf&quot;, &quot;af8cfcba675ae98ae5a6e238b2844238&quot;);
cookie.put(&quot;_za&quot;, &quot;7699d7fa-905b-44bf-9a08-583ca27692b3&quot;);
cookie.put(&quot;__utma&quot;, &quot;51854390.1095779136.1452616328.1452616328.1452616328.1&quot;);
cookie.put(&quot;__utmb&quot;, &quot;51854390.14.10.1452616328&quot;);
cookie.put(&quot;__utmc&quot;, &quot;51854390&quot;);
//...许多cookie，省略
con.cookies(cookie);
Connection.Response rs = con.execute();
Document doc = Jsoup.parse(rs.body());
System.out.println(doc);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果如之前所料，是已登录的状态&lt;/p&gt;

&lt;p&gt;此方法只是权宜之计，比如临时写一个只会用几次的爬虫程序&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;模拟登录知乎&lt;/h3&gt;

&lt;p&gt;下面一步步分析&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;1.请求地址&lt;/h4&gt;
&lt;p&gt;使用chrome开发者工具中的network功能抓取：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Request URL:https://www.zhihu.com/login/email&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-2&quot;&gt;2.需要哪些字段&lt;/h4&gt;

&lt;p&gt;打开知乎首页，观察登录表单&lt;/p&gt;

&lt;p&gt;帐号密码输入框、验证码输入框&lt;/p&gt;

&lt;p&gt;随便填几个值，点登录，使用chrome开发者工具中的network功能抓取请求头form data：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_xsrf:88d1ff7fd5a1f66f306b8f720a7322b8
password:123456
captcha:1234
remember_me:true
email:12345678
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发现五个字段&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;_xsrf，暂时不知道作用，猜测是一种验证机制&lt;/li&gt;
  &lt;li&gt;email、password，见名知意，帐号密码&lt;/li&gt;
  &lt;li&gt;remember，是否记住帐号&lt;/li&gt;
  &lt;li&gt;captcha，验证码值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;只有_xsrf不知其意，查看网页源代码，发现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;input type=&quot;hidden&quot; name=&quot;_xsrf&quot; value=&quot;88d1ff7fd5a1f66f306b8f720a7322b8&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;ok，管你是什么意思，我先发一次请求拿到你，第二次的时候直接塞进去不就得了
如码所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void getXsrf() {
		con = Jsoup.connect(&quot;http://www.zhihu.com&quot;);
		con.header(&quot;User-Agent&quot;, userAgent);
		try {
			rs = con.execute();
		} catch (Exception e) {
			log.info(&quot;获得Xsrf失败&quot;);
			return;
		}
		Document doc=Jsoup.parse(rs.body());
		_xsrf=doc.select(&quot;.view.view-signin [name=\&quot;_xsrf\&quot;]&quot;).attr(&quot;value&quot;);
		log.info(&quot;已获得xsrf&quot;);
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-3&quot;&gt;3.如何获取验证码&lt;/h4&gt;

&lt;p&gt;查看网页源代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;img class=&quot;js-refresh-captcha captcha&quot; width=&quot;120&quot; height=&quot;30&quot; data-tip=&quot;s$t$看不清楚？换一张&quot; alt=&quot;验证码&quot; src=&quot;/captcha.gif?r=1453549553883&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;得到验证码地址：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;www.zhihu.com/captcha.gif?r=一些数字&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;很容易可以看出，r的值为Unix时间戳&lt;/p&gt;

&lt;p&gt;下一步，代码实现下载验证码到本地，并保存该验证码的cookie，为后面登录做准备&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private Map&amp;lt;String,String&amp;gt; captchaCookies =new HashMap&amp;lt;&amp;gt;();
....
public void getCaptcha() {
		captchaCookies.clear();
		log.info(System.currentTimeMillis());
		con = Jsoup.connect(&quot;https://www.zhihu.com/captcha.gif?r=&quot; + System.currentTimeMillis()).ignoreContentType(true);//获取连接
		con.header(&quot;User-Agent&quot;, userAgent);
		try {
			rs = con.execute();
		} catch (Exception e) {
			log.info(&quot;获得验证码cookie失败&quot;);
			return;
		}
		File file = new File(&quot;cabeza.gif&quot;);
		try {
			FileOutputStream out = (new FileOutputStream(file));
			out.write(rs.bodyAsBytes());
		} catch (IOException e) {
			e.printStackTrace();
		}
		captchaCookies.putAll(rs.cookies());
		log.info(&quot;验证码已保存&quot; + &quot;,路径为:&quot; + file.getAbsolutePath());
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;验证码和对应cookie拿到后，下面就是登录了&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;4.根据上述五个字段，实现登录&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void getLoginCookies() {
    loginCookies.clear();
    Scanner sc=new Scanner(System.in);
    getXsrf();	//获取_xsrf
    getCaptchaCookies();	//获取验证码和验证码cookie
    log.info(&quot;请输入帐号&quot;);
    String userName=sc.nextLine();
    log.info(&quot;请输入密码&quot;);
    String passWord=sc.nextLine();
    log.info(&quot;请打开工程路径查看验证码并输入&quot;);
    String captcha=sc.nextLine();
    con = Jsoup.connect(&quot;https://www.zhihu.com/login/email&quot;);
    con.header(&quot;User-Agent&quot;, userAgent);
    try {
        rs = con.ignoreContentType(true).method(Connection.Method.POST)
                .data(&quot;_xsrf&quot;, _xsrf)
                .data(&quot;email&quot;, userName)
                .data(&quot;password&quot;, passWord)
                .data(&quot;captcha&quot;, captcha).cookies(captchaCookies).execute();
    } catch (Exception e) {
        log.info(&quot;获得loginCookies失败&quot;);
        return;
    }
    loginCookies.putAll(rs.cookies());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-5&quot;&gt;5.一些后续工作&lt;/h4&gt;
&lt;p&gt;拿到登录cookie后，为了方便下次登录，可以将cookie保存到文件，下次先从文件读取cookie登录，若失败，再使用上文方法登录&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void saveCookies(String fileName, Map&amp;lt;String, String&amp;gt; cookies) {
    FileOutputStream fos = null;
    try {
        fos = new FileOutputStream(fileName);
    } catch (IOException e) {
        e.printStackTrace();
    }
    BufferedOutputStream bos
            = new BufferedOutputStream(fos);
    PrintWriter pw = new PrintWriter(bos);
    for (Map.Entry&amp;lt;String, String&amp;gt; entry : cookies.entrySet()) {
        pw.println(entry.getKey() + &quot;=&quot; + entry.getValue().replace(&quot;\&quot;&quot;,&quot;&quot;));
    }
    pw.close();
    log.info(&quot;cookies已保存&quot;);
}
public void readCookies(String filename) {
    loginCookies.clear();
    try {
        FileInputStream fis
                = new FileInputStream(filename);
        InputStreamReader isr
                = new InputStreamReader(fis);
        BufferedReader br
                = new BufferedReader(isr);
        String str = null;
        while ((str = br.readLine()) != null) {
            int index = str.indexOf(&quot;=&quot;);
            loginCookies.put(
                    str.substring(0, index),
                    str.substring(index + 1, str.length())
            );
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
    log.info(loginCookies);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从文件读取cookie登录&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean loginBySavedCookies() {
    readCookies(&quot;zhihu_cookies.txt&quot;);
    con = Jsoup.connect(&quot;https://www.zhihu.com&quot;);//获取连接
    con.header(&quot;User-Agent&quot;, userAgent);//配置模拟浏览器
    con.cookies(loginCookies);
    try {
        rs = con.execute();
    } catch (Exception e) {
        log.info(&quot;读取Cookie登录失败&quot;);
        return false;
    }
    Document doc = Jsoup.parse(rs.body());
    if (checkLogin(doc))
        return true;
    log.info(&quot;读取cookie登录失败,下面手动登录:&quot;);
    return login();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此，一个简单的模拟登录程序就完成了&lt;/p&gt;
</description>
        <pubDate>Sat, 23 Jan 2016 00:00:00 +0000</pubDate>
        <link>cabeza.cn/blog/2016/01/23/jsoup-learning-note-3/</link>
        <guid isPermaLink="true">cabeza.cn/blog/2016/01/23/jsoup-learning-note-3/</guid>
        
        <category>java</category>
        
        <category>jsoup</category>
        
        <category>html</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>jsoup学习笔记(二):读取知乎个人首页动态</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在使用一段时间jsoup后，不满足仅仅处理一些本地文件，因知乎上不提供特别关注某位答主的功能，所以准备慢慢写一个监控动态的工具&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;jsoupurl&quot;&gt;jsoup从url加载网页&lt;/h4&gt;

&lt;p&gt;使用jsoup的connect方法，但注意&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;要在消息头内添加user-agent信息，用来模拟浏览器&lt;/li&gt;
  &lt;li&gt;合理设置timeout数值，防止异常&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Connection con = Jsoup.connect(&quot;https://www.zhihu.com/people/rednaxelafx&quot;);//获取连接
con.header(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:29.0) Gecko/20100101 Firefox/29.0&quot;);//配置模拟浏览器
con.timeout(3000);
Connection.Response rs = con.execute();//拿到返回的response信息
Document doc = Jsoup.parse(rs.body());//得到目标url的dom结构&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;execute方法会抛出IOException，注意用try-catch语句包住或throws掉&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;dom&quot;&gt;分析网页dom结构，编写对应的解析方法&lt;/h4&gt;

&lt;p&gt;首先观察dom结构
&lt;img src=&quot;http://7xq9w1.com1.z0.glb.clouddn.com/2016-01-16-jsoup-learning-note-2-1.jpg&quot; alt=&quot;知乎个人动态的dom结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发现个人动态都是包裹在 &lt;em&gt;class=”zm-profile-section-item zm-item clearfix”&lt;/em&gt; 的div内的&lt;/p&gt;

&lt;p&gt;而 &lt;em&gt;data-time&lt;/em&gt; 属性内的值稍有编程经验的人都可看出是unix时间戳，分析其是该条动态的时间信息&lt;/p&gt;

&lt;p&gt;据此可以拿到当前页的个人动态的dom集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Elements elmts = doc.select(&quot;.zm-profile-section-item.zm-item.clearfix&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进行遍历后遍可输出本次请求获取的所有个人动态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//使用SimpleDateFormat格式化unix时间戳
SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;);
for (Element elmt : elmts) {
	System.out.println(sdf.format(new java.util.Date(Long.parseLong(elmt.attr(&quot;data-time&quot;)) * 1000)));
	System.out.println(elmt.select(&quot;.zm-profile-activity-page-item-main&quot;).text() + &quot;www.zhihu.com&quot; + elmt.select(&quot;.question_link&quot;).attr(&quot;href&quot;));
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码块内，个人动态的url是使用 &lt;em&gt;baseUrl+quetion_link&lt;/em&gt; 形式拼起来的，也可以使用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;elmt.select(&quot;.question_link&quot;).attr(&quot;abs:href&quot;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有的时候直接使用 &lt;em&gt;abs:href&lt;/em&gt; 读取不到正确的绝对地址，这时候需要在document处指定baseUrl:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;doc.setBaseUri(&quot;https://www.zhihu.com&quot;);
...
elmt.select(&quot;.question_link&quot;).attr(&quot;abs:href&quot;);//这时候读取到的就是正确的url了
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在就可以读取某人首页地址并输出他的动态信息了&lt;/p&gt;

&lt;p&gt;但是会发现一个问题，未登录用户（显然上文用jsoup访问url属于未登录）在访问某人首页时会存在延迟（即他的最新动态不能及时获取），延迟时间大概是10~20分钟&lt;/p&gt;

&lt;p&gt;而已登录用户（如在浏览器内登录）刷新某人首页则是实时显示他的动态&lt;/p&gt;

&lt;p&gt;推测是知乎为了防止爬虫频繁刷取页面&lt;/p&gt;

&lt;p&gt;下一步就是用jsoup模拟登录了！&lt;/p&gt;

</description>
        <pubDate>Tue, 19 Jan 2016 00:00:00 +0000</pubDate>
        <link>cabeza.cn/blog/2016/01/19/jsoup-learning-note-2/</link>
        <guid isPermaLink="true">cabeza.cn/blog/2016/01/19/jsoup-learning-note-2/</guid>
        
        <category>java</category>
        
        <category>jsoup</category>
        
        <category>html</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>jsoup学习笔记(一):一个简单的html处理工具</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;因最近在开发中需要对网页做特定处理，如px转为rem、类名的替换、class转为id、对某class进行排序等。
虽然用java里String的一些方法如正则替换等也能做到，但是会非常繁琐，所以抽出时间学习一下html解析器:jsoup，
然后写了一个小小的工具&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;jsoup&quot;&gt;什么是jsoup&lt;/h3&gt;
&lt;p&gt;jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/jhy/jsoup&quot;&gt;jsoup的github地址&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;如何使用&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;使用jsoup要求你有一定的html、css知识&lt;/em&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-1&quot;&gt;1、从文件解析一个页面&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;Document doc=Jsoup.parse(new File(&quot;something&quot;),&quot;utf-8&quot;);//Document是一个装载html的文档类
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-2&quot;&gt;2、选择器&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;Elements elmt=doc.select(&quot;selector&quot;); //与css选择器语法一致
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-3&quot;&gt;3、常用方法&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;elmt.removeClass(&quot;className&quot;);   //删除指定的class
elmt.attr(&quot;id&quot;,&quot;wtf&quot;);           //添加属性
elmt.removeAttr(&quot;class&quot;);        //删除属性
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有时候我们需要对整个dom树做一次遍历，这时候可以通过NodeVisitor来遍历&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface NodeVisitor {
    //遍历到节点开始时，调用此方法
    public void head(Node node, int depth);
    //遍历到节点结束时(所有子节点都已遍历完)，调用此方法
    public void tail(Node node, int depth);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法还有很多，大多数都能见名知意，就不一一列举了
&lt;strong&gt;&lt;a href=&quot;http://jsoup.org/apidocs/&quot;&gt;jsoup的api&lt;/a&gt;&lt;/strong&gt;
具体例子见下文我的小demo&lt;/p&gt;

&lt;h3 id=&quot;demo&quot;&gt;一个简单的小demo&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;最近在调整html模版中遇到了这么几个需求&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;classidclassclass&quot;&gt;需求一：将指定的class属性替换为id属性,若替换后class属性为空，将class属性删除&lt;/h5&gt;
&lt;p&gt;一个很简单的功能，但如果纯用java String来做的话会相对很繁琐&lt;/p&gt;

&lt;p&gt;用jsoup就很方便了，先用选择器选出指定的class组，对其遍历，删除原class，再添加同名的id属性即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void classConvertToId(String className,String idName){
        Elements elmts=doc.select(className);
        for(Element elmt:elmts){
            elmt.removeClass(className.replaceAll(&quot;\\.|#&quot;,&quot;&quot;));
            elmt.attr(&quot;id&quot;,idName.replaceAll(&quot;\\.|#&quot;,&quot;&quot;));
            if(elmt.attr(&quot;class&quot;).isEmpty())
                elmt.removeAttr(&quot;class&quot;);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是不是很简单呢，有点类似js的风格了&lt;/p&gt;

&lt;h5 id=&quot;stylepxrem&quot;&gt;需求二：将页面内所有元素style属性内长度单位px转换为rem&lt;/h5&gt;
&lt;blockquote&gt;
  &lt;p&gt;因美工给我们的页面是以px为单位，而为了适配页面在不同尺寸设备上的效果，需要使用rem单位，因此产生此需求&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里就要用到上文提到的NodeVisitor了&lt;/p&gt;

&lt;p&gt;使用NodeVisitor和NodeTraversor进行遍历&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NodeVisitor visitor=new NodeVisitor() {
            @Override
            public void head(Node node, int i) {
                if (node.attr(&quot;style&quot;) != null &amp;amp;&amp;amp; !node.attr(&quot;style&quot;).isEmpty()) {
                    StringBuffer sb = new StringBuffer(node.attr(&quot;style&quot;));
			//doSomething here
                }
            }
        };
NodeTraversor tarversor=new NodeTraversor(visitor);
tarversor.traverse(doc);
		
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;顺便提一下，NodeTraversor的遍历是深度优先，核心代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public void traverse(Node root) {
    Node node = root;
    int depth = 0;
    while (node != null) {
        visitor.head(node, depth);
        if (node.childNodeSize() &amp;gt; 0) {
            node = node.childNode(0);
            depth++;
        } else {
            //退栈
            while (node.nextSibling() == null &amp;amp;&amp;amp; depth &amp;gt; 0) {
                visitor.tail(node, depth);
                node = node.parent();
                depth--;
            }
            //结束遍历
            visitor.tail(node, depth);
            if (node == root)
                break;
            node = node.nextSibling();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了扯回来，在遍历的过程中拿到元素style属性的内容(如果有的话)，然后查找内容中是否存在需要转换的值&lt;/p&gt;

&lt;p&gt;替换函数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void replaceByTarget(String startTarget,String endTarget,StringBuffer sb){
                pxStartIndex=0;
                pxEndIndex=0;
                while(pxEndIndex!=-1){
                    pxEndIndex=sb.indexOf(endTarget,pxEndIndex+1);
                    pxStartIndex=sb.lastIndexOf(startTarget,pxEndIndex)+1;
                    if(pxEndIndex!=-1){
                        try{
                            pxNum = Double.parseDouble(sb.substring(pxStartIndex, pxEndIndex).trim());
                        }catch(NumberFormatException e){
                            continue;
                        }
                        double remNum=pxNum/multiple;	//将px转换为rem，multiple为转换系数
                        sb.replace(pxStartIndex, pxEndIndex+2, remNum+&quot;rem&quot;);
                        pxStartIndex=0;
                        pxEndIndex=0;
                    }
                }
            }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，这个需求功能基本就实现了&lt;/p&gt;

&lt;p&gt;完整代码可以移步到我的github上:
&lt;strong&gt;&lt;a href=&quot;https://github.com/PorUnaCabeza/CabezaUtil/blob/master/src/util/HtmlModelUtil.java&quot;&gt;cabezaUtil&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 14 Jan 2016 00:00:00 +0000</pubDate>
        <link>cabeza.cn/blog/2016/01/14/jsoup-learning-note-1/</link>
        <guid isPermaLink="true">cabeza.cn/blog/2016/01/14/jsoup-learning-note-1/</guid>
        
        <category>java</category>
        
        <category>jsoup</category>
        
        <category>html</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>博客搬迁</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;博客搬迁&lt;/h2&gt;

&lt;p&gt;近期将以往博客搬迁过来&lt;/p&gt;
</description>
        <pubDate>Sun, 03 Jan 2016 00:00:00 +0000</pubDate>
        <link>cabeza.cn/blog/2016/01/03/init-blog/</link>
        <guid isPermaLink="true">cabeza.cn/blog/2016/01/03/init-blog/</guid>
        
        <category>生活</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>使用java写个简单游戏脚本（二）：JNI</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;上一次的小程序只是演示了一下如何用robot类控制鼠标键盘操作&lt;/p&gt;

  &lt;p&gt;这种方法有很大的弊端：1、不能后台运行。2、坐标代码写死，窗口甚至都不可移动。3、某些游戏会屏蔽该类
下面讲述下如何用JNI技术实现游戏内脚本后台执行&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;jni&quot;&gt;什么是JNI&lt;/h3&gt;
&lt;p&gt;简单讲就是实现了java和其他语言的通信，下面要用到是c或c++&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://baike.baidu.com/link?url=CMSZ7ybpBNF4ajNimLQfbiNAJXZS-66dLhw98oK1S6cJpwN9yMxZ-7weEuzx05nvFGY19bLXHR2AAFbdeo2C1K&quot;&gt;JNI&lt;/a&gt;自行阅读，不赘述&lt;/p&gt;

&lt;p&gt;&lt;em&gt;另：不到万不得已不要使用JNI，一方面它需要你掌握更多的知识才可以驾驭，一方面使用了JNI你的程序就会丧失可移植性&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;jni-1&quot;&gt;为什么要用JNI&lt;/h3&gt;
&lt;p&gt;java本身无法获得windows的接口，如窗口句柄等，需要借助c或c++&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;java代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
public class TowerUtil {
	public static native void keyPress(int hwnd, int key);
	public static native void mouseClick(int hwnd,int x,int y);
	static{
		System.loadLibrary(&quot;towerutil&quot;);
	}
	public static void main(String[] args) {
        int hwnd=1050990;
		TowerUtil.keyPress(hwnd, 0x42); 
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意keyPress和mouseClick函数的声明，它有一个关键字native，表明这个方法使用java以外的语言实现。方法不包括实现，因为我们要用c/c++语言实现它&lt;/p&gt;

&lt;p&gt;System.loadLibrary(“towerutil”)这句代码，在静态初始化块中定义的，用来装载towerutil.dll动态链接库&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;编译生成头文件&lt;/h3&gt;
&lt;p&gt;使用命令javah:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;javah TowerUtil.java&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文件内容如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
/* DO NOT EDIT THIS FILE - it is machine generated */
#include &quot;jni.h&quot;
/* Header for class TowerUtil */

#ifndef _Included_TowerUtil
#define _Included_TowerUtil
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
/*
 * Class:     TowerUtil
 * Method:    keyPress
 * Signature: (II)V
 */
JNIEXPORT void JNICALL Java_TowerUtil_keyPress
  (JNIEnv *, jclass, jint, jint);

/*
 * Class:     TowerUtil
 * Method:    mouseClick
 * Signature: (III)V
 */
JNIEXPORT void JNICALL Java_TowerUtil_mouseClick
  (JNIEnv *, jclass, jint, jint, jint);

#ifdef __cplusplus
}
#endif
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;cc&quot;&gt;用c/c++实现函数体&lt;/h3&gt;
&lt;p&gt;第三部里定义了keyPress和mouseClick两个函数，接下来要用c语言实现它，注意观察上一步生成的头文件里的函数名和参数，按照其来写
如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &quot;stdafx.h&quot;
#include &quot;jni.h&quot;
#include &quot;TowerUtil.h&quot;

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    return TRUE;
}
JNIEXPORT void JNICALL Java_TowerUtil_mouseClick
(JNIEnv *env, jobject obj, jint hwnd, jint x, jint y){
	LPARAM lparam = MAKELPARAM(x,y);
	SendMessage((HWND)hwnd, WM_LBUTTONDOWN, MK_LBUTTON, lparam);
	sleep(10);
	SendMessage((HWND)hwnd, WM_LBUTTONUP, MK_LBUTTON, lparam);
	return;
}
JNIEXPORT void JNICALL Java_TowerUtil_keyPress
  (JNIEnv *env, jobject obj, jint hwnd, jint key){
	SendMessage((HWND)hwnd,WM_KEYDOWN,key,0);
	sleep(100);
	SendMessage((HWND)hwnd,WM_KEYUP,key,0);
	return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于代码里出现的SendMessage函数:&lt;a href=&quot;http://jingyan.baidu.com/article/c45ad29cd5fb58051653e278.html&quot;&gt;SendMessage 函数参数大全&lt;/a&gt; 的
注意在开头引入jni.h和前面生成的TowerUtil.h
### 生成dll文件
下面生成前面提到的 towerutil.dll，windows可以下载MinGW进行编译:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;gcc -shared TowerUtil.cpp -o towerutil.dll -I （.h头文件目录）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;java-1&quot;&gt;运行java程序&lt;/h3&gt;
&lt;p&gt;把上面生成的dll文件加入到java.library.path内&lt;/p&gt;

&lt;p&gt;main函数里写上一行：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TowerUtil.keyPress(hwnd, 0x42);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;解释下， hwnd是我玩的完美国际当前的句柄值，0x42是键盘“b”的asiic值，游戏内b键打开背包
执行后可以看到游戏里的背包界面打开
大功告成！
再结合上一篇文章写到的脚本解析函数的思路，就可以写出一个略微简陋的游戏脚本执行器了
使用JNI的好处上面已提到，脚本编写好后，你可以把游戏最小化，也不影响执行
如果能够再获得游戏内属性基址，就能写出一个功能更丰富的??了&lt;/p&gt;
</description>
        <pubDate>Wed, 09 Sep 2015 00:00:00 +0000</pubDate>
        <link>cabeza.cn/blog/2015/09/09/use-java-for-game-script/</link>
        <guid isPermaLink="true">cabeza.cn/blog/2015/09/09/use-java-for-game-script/</guid>
        
        <category>java</category>
        
        <category>游戏</category>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
