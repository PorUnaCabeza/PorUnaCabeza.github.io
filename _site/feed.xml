<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Namárië</title>
    <description></description>
    <link>fdgdfgfdg/</link>
    <atom:link href="fdgdfgfdg/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 22 Jan 2016 10:40:24 +0000</pubDate>
    <lastBuildDate>Fri, 22 Jan 2016 10:40:24 +0000</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>jsoup学习笔记(二):读取知乎个人首页动态</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在使用一段时间jsoup后，不满足仅仅处理一些本地文件，因知乎上不提供特别关注某位答主的功能，所以准备慢慢写一个监控动态的工具&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;jsoupurl&quot;&gt;jsoup从url加载网页&lt;/h4&gt;

&lt;p&gt;使用jsoup的connect方法，但注意&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;要在消息头内添加user-agent信息，用来模拟浏览器&lt;/li&gt;
  &lt;li&gt;合理设置timeout数值，防止异常&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Connection con = Jsoup.connect(&quot;https://www.zhihu.com/people/rednaxelafx&quot;);//获取连接
con.header(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:29.0) Gecko/20100101 Firefox/29.0&quot;);//配置模拟浏览器
con.timeout(3000);
Connection.Response rs = con.execute();//拿到返回的response信息
Document doc = Jsoup.parse(rs.body());//得到目标url的dom结构&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;execute方法会抛出IOException，注意用try-catch语句包住或throws掉&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;dom&quot;&gt;分析网页dom结构，编写对应的解析方法&lt;/h4&gt;

&lt;p&gt;首先观察dom结构
&lt;img src=&quot;http://7xq9w1.com1.z0.glb.clouddn.com/2016-01-16-jsoup-learning-note-2-1.jpg&quot; alt=&quot;知乎个人动态的dom结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发现个人动态都是包裹在 &lt;em&gt;class=”zm-profile-section-item zm-item clearfix”&lt;/em&gt; 的div内的&lt;/p&gt;

&lt;p&gt;而 &lt;em&gt;data-time&lt;/em&gt; 属性内的值稍有编程经验的人都可看出是unix时间戳，分析其是该条动态的时间信息&lt;/p&gt;

&lt;p&gt;据此可以拿到当前页的个人动态的dom集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Elements elmts = doc.select(&quot;.zm-profile-section-item.zm-item.clearfix&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进行遍历后遍可输出本次请求获取的所有个人动态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//使用SimpleDateFormat格式化unix时间戳
SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;);
for (Element elmt : elmts) {
	System.out.println(sdf.format(new java.util.Date(Long.parseLong(elmt.attr(&quot;data-time&quot;)) * 1000)));
	System.out.println(elmt.select(&quot;.zm-profile-activity-page-item-main&quot;).text() + &quot;www.zhihu.com&quot; + elmt.select(&quot;.question_link&quot;).attr(&quot;href&quot;));
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码块内，个人动态的url是使用 &lt;em&gt;baseUrl+quetion_link&lt;/em&gt; 形式拼起来的，也可以使用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;elmt.select(&quot;.question_link&quot;).attr(&quot;abs:href&quot;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有的时候直接使用 &lt;em&gt;abs:href&lt;/em&gt; 读取不到正确的绝对地址，这时候需要在document处指定baseUrl:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;doc.setBaseUri(&quot;https://www.zhihu.com&quot;);
...
elmt.select(&quot;.question_link&quot;).attr(&quot;abs:href&quot;);//这时候读取到的就是正确的url了
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在就可以读取某人首页地址并输出他的动态信息了&lt;/p&gt;

&lt;p&gt;但是会发现一个问题，未登录用户（显然上文用jsoup访问url属于未登录）在访问某人首页时会存在延迟（即他的最新动态不能及时获取），延迟时间大概是10~20分钟&lt;/p&gt;

&lt;p&gt;而已登录用户（如在浏览器内登录）刷新某人首页则是实时显示他的动态&lt;/p&gt;

&lt;p&gt;推测是知乎为了防止爬虫频繁刷取页面&lt;/p&gt;

&lt;p&gt;下一步就是用jsoup模拟登录了！&lt;/p&gt;

</description>
        <pubDate>Tue, 19 Jan 2016 00:00:00 +0000</pubDate>
        <link>fdgdfgfdg/blog/2016/01/19/jsoup-learning-note-2/</link>
        <guid isPermaLink="true">fdgdfgfdg/blog/2016/01/19/jsoup-learning-note-2/</guid>
        
        <category>java</category>
        
        <category>jsoup</category>
        
        <category>html</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>jsoup学习笔记(一):一个简单的html处理工具</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;因最近在开发中需要对网页做特定处理，如px转为rem、类名的替换、class转为id、对某class进行排序等。
虽然用java里String的一些方法如正则替换等也能做到，但是会非常繁琐，所以抽出时间学习一下html解析器:jsoup，
然后写了一个小小的工具&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;jsoup&quot;&gt;什么是jsoup&lt;/h3&gt;
&lt;p&gt;jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/jhy/jsoup&quot;&gt;jsoup的github地址&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;如何使用&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;使用jsoup要求你有一定的html、css知识&lt;/em&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-1&quot;&gt;1、从文件解析一个页面&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;Document doc=Jsoup.parse(new File(&quot;something&quot;),&quot;utf-8&quot;);//Document是一个装载html的文档类
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-2&quot;&gt;2、选择器&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;Elements elmt=doc.select(&quot;selector&quot;); //与css选择器语法一致
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-3&quot;&gt;3、常用方法&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;elmt.removeClass(&quot;className&quot;);   //删除指定的class
elmt.attr(&quot;id&quot;,&quot;wtf&quot;);           //添加属性
elmt.removeAttr(&quot;class&quot;);        //删除属性
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有时候我们需要对整个dom树做一次遍历，这时候可以通过NodeVisitor来遍历&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface NodeVisitor {
    //遍历到节点开始时，调用此方法
    public void head(Node node, int depth);
    //遍历到节点结束时(所有子节点都已遍历完)，调用此方法
    public void tail(Node node, int depth);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法还有很多，大多数都能见名知意，就不一一列举了
&lt;strong&gt;&lt;a href=&quot;http://jsoup.org/apidocs/&quot;&gt;jsoup的api&lt;/a&gt;&lt;/strong&gt;
具体例子见下文我的小demo&lt;/p&gt;

&lt;h3 id=&quot;demo&quot;&gt;一个简单的小demo&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;最近在调整html模版中遇到了这么几个需求&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;classidclassclass&quot;&gt;需求一：将指定的class属性替换为id属性,若替换后class属性为空，将class属性删除&lt;/h5&gt;
&lt;p&gt;一个很简单的功能，但如果纯用java String来做的话会相对很繁琐&lt;/p&gt;

&lt;p&gt;用jsoup就很方便了，先用选择器选出指定的class组，对其遍历，删除原class，再添加同名的id属性即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void classConvertToId(String className,String idName){
        Elements elmts=doc.select(className);
        for(Element elmt:elmts){
            elmt.removeClass(className.replaceAll(&quot;\\.|#&quot;,&quot;&quot;));
            elmt.attr(&quot;id&quot;,idName.replaceAll(&quot;\\.|#&quot;,&quot;&quot;));
            if(elmt.attr(&quot;class&quot;).isEmpty())
                elmt.removeAttr(&quot;class&quot;);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是不是很简单呢，有点类似js的风格了&lt;/p&gt;

&lt;h5 id=&quot;stylepxrem&quot;&gt;需求二：将页面内所有元素style属性内长度单位px转换为rem&lt;/h5&gt;
&lt;blockquote&gt;
  &lt;p&gt;因美工给我们的页面是以px为单位，而为了适配页面在不同尺寸设备上的效果，需要使用rem单位，因此产生此需求&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里就要用到上文提到的NodeVisitor了&lt;/p&gt;

&lt;p&gt;使用NodeVisitor和NodeTraversor进行遍历&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NodeVisitor visitor=new NodeVisitor() {
            @Override
            public void head(Node node, int i) {
                if (node.attr(&quot;style&quot;) != null &amp;amp;&amp;amp; !node.attr(&quot;style&quot;).isEmpty()) {
                    StringBuffer sb = new StringBuffer(node.attr(&quot;style&quot;));
			//doSomething here
                }
            }
        };
NodeTraversor tarversor=new NodeTraversor(visitor);
tarversor.traverse(doc);
		
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;顺便提一下，NodeTraversor的遍历是深度优先，核心代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
public void traverse(Node root) {
    Node node = root;
    int depth = 0;
    while (node != null) {
        visitor.head(node, depth);
        if (node.childNodeSize() &amp;gt; 0) {
            node = node.childNode(0);
            depth++;
        } else {
            //退栈
            while (node.nextSibling() == null &amp;amp;&amp;amp; depth &amp;gt; 0) {
                visitor.tail(node, depth);
                node = node.parent();
                depth--;
            }
            //结束遍历
            visitor.tail(node, depth);
            if (node == root)
                break;
            node = node.nextSibling();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了扯回来，在遍历的过程中拿到元素style属性的内容(如果有的话)，然后查找内容中是否存在需要转换的值&lt;/p&gt;

&lt;p&gt;替换函数:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void replaceByTarget(String startTarget,String endTarget,StringBuffer sb){
                pxStartIndex=0;
                pxEndIndex=0;
                while(pxEndIndex!=-1){
                    pxEndIndex=sb.indexOf(endTarget,pxEndIndex+1);
                    pxStartIndex=sb.lastIndexOf(startTarget,pxEndIndex)+1;
                    if(pxEndIndex!=-1){
                        try{
                            pxNum = Double.parseDouble(sb.substring(pxStartIndex, pxEndIndex).trim());
                        }catch(NumberFormatException e){
                            continue;
                        }
                        double remNum=pxNum/multiple;	//将px转换为rem，multiple为转换系数
                        sb.replace(pxStartIndex, pxEndIndex+2, remNum+&quot;rem&quot;);
                        pxStartIndex=0;
                        pxEndIndex=0;
                    }
                }
            }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，这个需求功能基本就实现了&lt;/p&gt;

&lt;p&gt;完整代码可以移步到我的github上:
&lt;strong&gt;&lt;a href=&quot;https://github.com/PorUnaCabeza/CabezaUtil/blob/master/src/util/HtmlModelUtil.java&quot;&gt;cabezaUtil&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 14 Jan 2016 00:00:00 +0000</pubDate>
        <link>fdgdfgfdg/blog/2016/01/14/jsoup-learning-note-1/</link>
        <guid isPermaLink="true">fdgdfgfdg/blog/2016/01/14/jsoup-learning-note-1/</guid>
        
        <category>java</category>
        
        <category>jsoup</category>
        
        <category>html</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>博客搬迁</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;博客搬迁&lt;/h2&gt;

&lt;p&gt;近期将以往博客搬迁过来&lt;/p&gt;
</description>
        <pubDate>Sun, 03 Jan 2016 00:00:00 +0000</pubDate>
        <link>fdgdfgfdg/blog/2016/01/03/init-blog/</link>
        <guid isPermaLink="true">fdgdfgfdg/blog/2016/01/03/init-blog/</guid>
        
        <category>生活</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>使用java写个简单游戏脚本（二）：JNI</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;上一次的小程序只是演示了一下如何用robot类控制鼠标键盘操作&lt;/p&gt;

  &lt;p&gt;这种方法有很大的弊端：1、不能后台运行。2、坐标代码写死，窗口甚至都不可移动。3、某些游戏会屏蔽该类
下面讲述下如何用JNI技术实现游戏内脚本后台执行&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;jni&quot;&gt;什么是JNI&lt;/h3&gt;
&lt;p&gt;简单讲就是实现了java和其他语言的通信，下面要用到是c或c++&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://baike.baidu.com/link?url=CMSZ7ybpBNF4ajNimLQfbiNAJXZS-66dLhw98oK1S6cJpwN9yMxZ-7weEuzx05nvFGY19bLXHR2AAFbdeo2C1K&quot;&gt;JNI&lt;/a&gt;自行阅读，不赘述&lt;/p&gt;

&lt;p&gt;&lt;em&gt;另：不到万不得已不要使用JNI，一方面它需要你掌握更多的知识才可以驾驭，一方面使用了JNI你的程序就会丧失可移植性&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;jni-1&quot;&gt;为什么要用JNI&lt;/h3&gt;
&lt;p&gt;java本身无法获得windows的接口，如窗口句柄等，需要借助c或c++&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;java代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
public class TowerUtil {
	public static native void keyPress(int hwnd, int key);
	public static native void mouseClick(int hwnd,int x,int y);
	static{
		System.loadLibrary(&quot;towerutil&quot;);
	}
	public static void main(String[] args) {
        int hwnd=1050990;
		TowerUtil.keyPress(hwnd, 0x42); 
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意keyPress和mouseClick函数的声明，它有一个关键字native，表明这个方法使用java以外的语言实现。方法不包括实现，因为我们要用c/c++语言实现它&lt;/p&gt;

&lt;p&gt;System.loadLibrary(“towerutil”)这句代码，在静态初始化块中定义的，用来装载towerutil.dll动态链接库&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;编译生成头文件&lt;/h3&gt;
&lt;p&gt;使用命令javah:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;javah TowerUtil.java&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文件内容如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
/* DO NOT EDIT THIS FILE - it is machine generated */
#include &quot;jni.h&quot;
/* Header for class TowerUtil */

#ifndef _Included_TowerUtil
#define _Included_TowerUtil
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
/*
 * Class:     TowerUtil
 * Method:    keyPress
 * Signature: (II)V
 */
JNIEXPORT void JNICALL Java_TowerUtil_keyPress
  (JNIEnv *, jclass, jint, jint);

/*
 * Class:     TowerUtil
 * Method:    mouseClick
 * Signature: (III)V
 */
JNIEXPORT void JNICALL Java_TowerUtil_mouseClick
  (JNIEnv *, jclass, jint, jint, jint);

#ifdef __cplusplus
}
#endif
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;cc&quot;&gt;用c/c++实现函数体&lt;/h3&gt;
&lt;p&gt;第三部里定义了keyPress和mouseClick两个函数，接下来要用c语言实现它，注意观察上一步生成的头文件里的函数名和参数，按照其来写
如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#include &quot;stdafx.h&quot;
#include &quot;jni.h&quot;
#include &quot;TowerUtil.h&quot;

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    return TRUE;
}
JNIEXPORT void JNICALL Java_TowerUtil_mouseClick
(JNIEnv *env, jobject obj, jint hwnd, jint x, jint y){
	LPARAM lparam = MAKELPARAM(x,y);
	SendMessage((HWND)hwnd, WM_LBUTTONDOWN, MK_LBUTTON, lparam);
	sleep(10);
	SendMessage((HWND)hwnd, WM_LBUTTONUP, MK_LBUTTON, lparam);
	return;
}
JNIEXPORT void JNICALL Java_TowerUtil_keyPress
  (JNIEnv *env, jobject obj, jint hwnd, jint key){
	SendMessage((HWND)hwnd,WM_KEYDOWN,key,0);
	sleep(100);
	SendMessage((HWND)hwnd,WM_KEYUP,key,0);
	return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于代码里出现的SendMessage函数:&lt;a href=&quot;http://jingyan.baidu.com/article/c45ad29cd5fb58051653e278.html&quot;&gt;SendMessage 函数参数大全&lt;/a&gt; 的
注意在开头引入jni.h和前面生成的TowerUtil.h
### 生成dll文件
下面生成前面提到的 towerutil.dll，windows可以下载MinGW进行编译:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;gcc -shared TowerUtil.cpp -o towerutil.dll -I （.h头文件目录）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;java-1&quot;&gt;运行java程序&lt;/h3&gt;
&lt;p&gt;把上面生成的dll文件加入到java.library.path内&lt;/p&gt;

&lt;p&gt;main函数里写上一行：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TowerUtil.keyPress(hwnd, 0x42);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;解释下， hwnd是我玩的完美国际当前的句柄值，0x42是键盘“b”的asiic值，游戏内b键打开背包
执行后可以看到游戏里的背包界面打开
大功告成！
再结合上一篇文章写到的脚本解析函数的思路，就可以写出一个略微简陋的游戏脚本执行器了
使用JNI的好处上面已提到，脚本编写好后，你可以把游戏最小化，也不影响执行
如果能够再获得游戏内属性基址，就能写出一个功能更丰富的??了&lt;/p&gt;
</description>
        <pubDate>Wed, 09 Sep 2015 00:00:00 +0000</pubDate>
        <link>fdgdfgfdg/blog/2015/09/09/use-java-for-game-script/</link>
        <guid isPermaLink="true">fdgdfgfdg/blog/2015/09/09/use-java-for-game-script/</guid>
        
        <category>java</category>
        
        <category>游戏</category>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
